*p.60

이 질문은 데이터베이스에서 **Multiblock I/O**가 진행되는 도중에 왜 **Single Block I/O**가 발생하는지에 대한 문제입니다. 이를 이해하기 위해서는 각 용어와 과정을 차근차근 살펴보는 것이 중요합니다.

### 1. **익스텐트 맵(Extent Map)**

- **익스텐트(Extent)**는 데이터베이스에서 테이블이나 인덱스가 저장되는 연속적인 데이터 블록 그룹입니다. 데이터베이스가 데이터를 저장할 때, 이 데이터가 여러 개의 블록에 나누어 저장되는데, 이러한 블록들의 그룹을 **익스텐트**라고 합니다.
- **익스텐트 맵**은 데이터베이스에서 익스텐트가 어느 블록에 저장되었는지에 대한 정보가 담긴 인덱스와 같은 역할을 합니다. 이를 통해 특정 데이터를 찾기 위해 어떤 블록들을 읽어야 하는지 알아낼 수 있습니다.

### 2. **Multiblock I/O**

- **Multiblock I/O**는 한 번에 여러 개의 블록을 읽는 방식입니다. 대량의 데이터를 처리할 때, 여러 블록을 동시에 읽는 것이 효율적이기 때문에 이 방식을 사용합니다. 예를 들어, 한번에 4개의 블록을 읽어들인다고 가정하면, 이는 **Multiblock I/O 단위가 4**라는 의미입니다.
- **Batch I/O**라고도 불리는 Multiblock I/O는 대량의 데이터를 빠르게 처리하기 위해 설계되었습니다.

### 3. **Single Block I/O**

- **Single Block I/O**는 한 번에 한 개의 블록만 읽는 방식입니다. 특정 블록만을 읽어야 할 때 사용되며, Multiblock I/O에 비해 느리지만 메모리에 없는 특정 데이터를 불러올 때 사용됩니다.

### 4. **캐시버퍼 체인(Cache Buffer Chain)**

- **캐시버퍼 체인**은 메모리에 저장된 데이터 블록들이 연결된 구조입니다. 데이터베이스는 디스크에서 데이터를 읽기 전에 메모리(캐시)에 이미 해당 데이터가 있는지 먼저 확인합니다. 이때 캐시버퍼 체인에서 필요한 데이터 블록을 찾습니다.

---
**Multiblock I/O 단위가 4라고 가정하고, 익스텐트 맵에서 1번에서 10번까지의 블록을 읽는 상황을 가정해 봅시다.**

1. **첫 번째 블록(1번)**:
   - 캐시버퍼 체인에서 **1번 블록**을 찾습니다.
   - **1번 블록**이 이미 메모리에 있기 때문에 디스크 접근 없이 바로 **메모리에서 읽습니다**. 즉, **캐시에서 읽는 작업**이 발생합니다.

2. **2번, 3번, 4번, 5번 블록**:
   - 캐시버퍼 체인에서 **2번, 3번, 4번, 5번 블록**을 찾습니다.
   - 이 블록들은 캐시에 없으므로 **디스크에서 읽어야 합니다**.
   - 이때, **Multiblock I/O** 방식을 사용하여 **2번부터 5번까지**의 블록을 한 번에 읽어들입니다.
   - 이 과정을 통해 **디스크에서 읽은 데이터**는 메모리에 저장되고, 바로 사용됩니다.

3. **6번 블록**:
   - 캐시버퍼 체인에서 **6번 블록**을 찾습니다.
   - **6번 블록**이 메모리에 있으므로 바로 **캐시에서 읽습니다**.

4. **7번 블록**:
   - 캐시버퍼 체인에서 **7번 블록**을 찾습니다.
   - **7번 블록**이 메모리에 없으므로 **디스크에서 읽어야 합니다**.
   - 이때는 **Multiblock I/O** 대신 **Single Block I/O** 방식이 사용됩니다. 왜냐하면 7번 블록을 읽을 때 8번 블록은 이미 메모리에 있기 때문입니다. 따라서 7번 블록만 **디스크에서 읽어** 옵니다.

5. **9번, 10번 블록**:
   - 캐시버퍼 체인에서 **9번 블록**을 찾습니다.
   - **9번 블록**이 메모리에 캐시되어 있으므로 바로 **캐시에서 읽습니다**.
   - **10번 블록**은 캐시에 없으므로 **디스크에서 읽어야 합니다**.
   - 이때, **10번 블록은 익스텐트의 마지막 블록이기 때문에** 다시 **Single Block I/O** 방식으로 디스크에서 읽습니다.

---

### 왜 **Single Block I/O**가 나타나는가?

1. **캐시 상태**: 
   - 일부 블록은 메모리 캐시에 이미 존재하기 때문에, **Multiblock I/O**가 아닌 **Single Block I/O**가 발생합니다. 캐시된 블록을 제외한 나머지 블록만 디스크에서 읽어야 하기 때문에 Multiblock I/O가 끊어질 수 있습니다.

2. **익스텐트의 끝**: 
   - **익스텐트의 마지막 블록**에서는 **Single Block I/O**가 사용됩니다. 이는 데이터베이스가 마지막 블록을 처리할 때 Multiblock I/O 단위로 데이터를 읽는 것이 효율적이지 않기 때문입니다.

### 요약

- **Multiblock I/O**는 한 번에 여러 개의 블록을 읽어 효율을 높이는 방식이며, **Single Block I/O**는 특정 블록을 읽기 위해 사용됩니다.
- **Single Block I/O**는 주로 메모리에 없는 특정 블록을 읽거나, 익스텐트의 마지막 블록을 처리할 때 사용됩니다.

p.62
**카디널리티(Cardinality)**는 데이터베이스에서 **특정 컬럼의 고유 값의 수**를 나타내는 용어입니다. 즉, 해당 컬럼에 얼마나 다양한 값이 들어있는지를 의미합니다.

### 예시:
- 예를 들어, `고객` 테이블에서 `성별`이라는 컬럼이 있다고 합시다. 이 컬럼은 `남성`과 `여성`이라는 두 가지 값만을 가질 수 있습니다. 이 경우, `성별` 컬럼의 카디널리티는 2입니다.
- 반면에 `주민등록번호`라는 컬럼은 각 고객마다 고유한 값을 가집니다. 따라서 `주민등록번호` 컬럼의 카디널리티는 테이블의 전체 행 수와 같습니다. 즉, 카디널리티가 매우 높습니다.

### 카디널리티와 SQL 튜닝:
- **카디널리티가 낮은 경우** (즉, 컬럼의 고유 값이 적을 때), 해당 컬럼에 인덱스를 사용해도 성능 개선에 큰 도움이 되지 않을 수 있습니다. 왜냐하면 인덱스를 통해 데이터를 찾는 작업이 많아지고, 결국 테이블 전체를 스캔하는 것과 차이가 없어지기 때문입니다.
- **카디널리티가 높은 경우** (즉, 고유 값이 많은 컬럼), 인덱스를 사용하면 성능이 크게 향상될 수 있습니다. 고유 값이 많기 때문에 인덱스를 통해 정확하게 데이터를 찾을 수 있기 때문입니다.

튜닝에서 중요한 것은 **어떤 상황에서 인덱스를 사용하고, 어떤 상황에서 Table Full Scan이 더 나은지**를 판단하는 것입니다. 카디널리티가 중요한 이유는 이를 통해 인덱스 사용의 효율성을 판단할 수 있기 때문입니다.